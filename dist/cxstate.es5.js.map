{"version":3,"file":"cxstate.es5.js","sources":["../src/lib.ts","../src/index.ts","../src/fns.ts"],"sourcesContent":["import {\n  EventDef,\n  StateDef,\n  StateConfig,\n} from './types';\n\nexport function rebuildActiveStates<TContext>(\n  currentState: StateConfig<TContext>,\n  previousActiveStates: StateConfig<TContext>[],\n  statePaths: StateConfig<TContext>[],\n) {\n  if (previousActiveStates[previousActiveStates.length-1] === currentState) {\n    return previousActiveStates;\n  }\n  const comps = currentState.path.absolute.split('/').filter(c => c.length);\n  const acc: StateConfig<TContext>[] = [];\n  for (let i = 1; i <= comps.length; i++) {\n    const path = `/${comps.slice(0, i).join('/')}`;\n    const parentResult = previousActiveStates.find(sp => sp.path.absolute === path);\n    const result = parentResult || statePaths.find(sp => sp.path.absolute === path);\n    if (result) acc.push(result);\n    else throw new Error(`No state found for path \"${path}\"`);\n  }\n  return acc;\n}\n\nexport function findInitialChildState<TContext>(\n  ctx: TContext,\n  statePaths: StateConfig<TContext>[],\n  parent: StateConfig<TContext>,\n) :StateConfig<TContext>|undefined {\n  if (hasChildStates(parent.state)) {\n    if (parent.state.initial) {\n      let initial = initialStateName<TContext>(parent.state.initial, ctx);\n      const basePath = parent.path.absolute.endsWith('/')\n        ? parent.path.absolute\n        : `${parent.path.absolute}/`;\n      const absolutePath = resolvePath(basePath, initial);\n      const child = statePaths.find(sp => sp.path.absolute === absolutePath);\n      if (child) {\n        if (hasChildStates(child.state)) {\n          return findInitialChildState(ctx, statePaths, child);\n        } else {\n          return child;\n        }\n      } else {\n        throw new Error(`State \"${parent.path.absolute}\" initial state \"${initial}\" doesn't match any of the definitions`);\n      }\n    } else {\n      throw new Error(`State \"${parent.path.absolute}\" has child-states, but doesn't define initial`);\n    }\n  }\n}\n\nfunction hasChildStates<TContext>(state: StateDef<TContext>) :boolean {\n  return !!(state.states && Object.values(state.states).length);\n}\n\nexport function updateContext<TContext, TPayload>(\n  ctx: TContext,\n  def: EventDef<TContext>,\n  payload?: TPayload,\n) {\n  const update = {...ctx};\n  let didUpdate = false;\n  for (const propName in def.update) {\n    const anyFn = def.update[propName];\n    if (typeof anyFn === 'function') {\n      const fn = anyFn as (ctx: TContext, pl?: TPayload) => any;\n      const changedValue = fn(update, payload);\n      if (changedValue !== update[propName]) {\n        update[propName] = changedValue;\n        didUpdate = true;\n      }\n    }\n  }\n  if (didUpdate) return update;\n}\n\nexport function initialStateName<TContext>(\n  initial: string|((ctx: TContext) => string),\n  ctx: TContext,\n) {\n  return (typeof initial === 'string') ? initial : initial(ctx);\n}\n\nexport function resolvePath(base: string, relativeComp: string) {\n  if (!base.startsWith('/')) throw new Error('Base component of path must start with /');\n  const host = 'http://con5.app';\n  const url = (new URL(relativeComp, `${host}${base}`)).href;\n  return url.slice(host.length);\n}\n","import {\n  EventDef,\n  EventErrorType,\n  StateDef,\n  MachineDef,\n  Service,\n  StateConfig,\n  OnTransitionFn,\n} from './types';\n\nimport {\n  rebuildActiveStates,\n  findInitialChildState,\n  updateContext,\n  initialStateName,\n  resolvePath,\n} from './lib';\n\n/**\n * Internprets a machine-definition. Returns a ready to use machine-service.\n */\nexport function interpret<TContext>(\n  machineDef: MachineDef<TContext>,\n) :Service<TContext> {\n  const stateConfigs: StateConfig<TContext>[] = [];\n\n  const buildStateConfigs = (\n    basePath: string,\n    name: string,\n    state: StateDef<TContext>,\n  ) => {\n    const absolute = resolvePath(basePath, name);\n    stateConfigs.push({state, path: {name, absolute}});\n\n    if (state.states && Object.values(state.states).length) {\n      // Check minimum state validity\n      if (!state.initial) throw new Error(`State \"${absolute}\" has child-states, but doesn't define initial`);\n      // Check minimum validity of events\n      if (state.on) Object.entries(state.on).forEach(([eventName, eventDef]) => {\n        const checkEvent = (ed: string|EventDef<TContext>) => {\n          if (typeof ed !== 'string') {\n            if (ed.replace && ed.update) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <replace> and <update> are mutually exclusive`);\n            if (ed.target && ed.next) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <target> and <next> are mutually exclusive`);\n          }\n        };\n        if (eventDef instanceof Array) eventDef.forEach(checkEvent);\n        else checkEvent(eventDef);\n      });\n      const nextBasePath = absolute.endsWith('/') ? absolute : `${absolute}/`;\n      for (const [stateName, stateDef] of Object.entries(state.states)) {\n        buildStateConfigs(nextBasePath, stateName, stateDef);\n      }\n    }\n  };\n\n  for (const [stateName, stateDef] of Object.entries(machineDef.states)) {\n    buildStateConfigs('/', stateName, stateDef);\n  }\n\n  let initial = initialStateName<TContext>(machineDef.initial, machineDef.context);\n  const initialAbsPath = initial.startsWith('/') ? initial : `/${initial}`;\n  let initialState = stateConfigs.find(sp => sp.path.absolute === initialAbsPath);\n  if (initialState) {\n    const initialChild = findInitialChildState(machineDef.context, stateConfigs, initialState);\n    if (initialChild) {\n      initialState = initialChild;\n    }\n    return makeService(stateConfigs, machineDef.context, initialState);\n  } else {\n    throw new Error(`Initial state \"${initial}\" doesn't match any of the definitions`);\n  }\n}\n\nfunction makeService<TContext>(\n  stateConfigs: StateConfig<TContext>[],\n  initialContext: TContext,\n  initialState: StateConfig<TContext>,\n) :Service<TContext> {\n  let activeStates: StateConfig<TContext>[] =\n    rebuildActiveStates<TContext>(initialState, [], stateConfigs);\n  let currentContext: TContext = initialContext;\n  const listeners: OnTransitionFn<TContext>[] = [];\n  let matcherMemoization: {[key:string]: {result: boolean}} = {};\n  const eventPayloadPromises = new Map<string, Promise<any>>();\n  let isDirty: boolean = true;\n\n  const currentState = () => activeStates[activeStates.length - 1];\n\n  const findEventHandlerAndStateConfig = (eventName: string)\n  :[\n    string|EventDef<TContext>|EventDef<TContext>[]|null,\n    StateConfig<TContext>|null,\n  ] => {\n    for(let i = activeStates.length; i--;) {\n      const config = activeStates[i];\n      if (config.state.on) {\n        const handler = config.state.on[eventName];\n        if (handler) return [handler, config];\n      }\n    }\n    return [null, null];\n  };\n\n  const informListeners = () => {\n    for (const callback of listeners) {\n      callback(currentContext, currentState().path.absolute);\n    }\n    isDirty = false;\n  };\n\n  // TRANSITION HANDLING\n\n  const onTransition = (callback: OnTransitionFn<TContext>) => {\n    listeners.push(callback);\n    return () => {\n      const idx = listeners.indexOf(callback);\n      if (idx > -1) listeners.splice(idx, 1);\n    };\n  };\n\n  // from: state path in which the event handler was found\n  const transitionToTarget = <TPayload>(\n    target: string,\n    from: StateConfig<TContext>,\n    srcPayload: TPayload,\n  ) => {\n    if (target) {\n      const fsp = from.path;\n      const targetPath = resolvePath(`${fsp.absolute}/`, target);\n      const targetConfig = stateConfigs.find(sc => sc.path.absolute === targetPath);\n      if (targetConfig) {\n        transitionToState<TPayload>(targetConfig, srcPayload);\n      } else {\n        throw new Error(`No state defined for path \"${targetPath}\"`);\n      }\n    } else if (isDirty) {\n      informListeners();\n    }\n  };\n\n  // ACTIVE STATE HANDLING\n\n  const transitionToState = <TPayload>(\n    parent: StateConfig<TContext>,\n    srcPayload: TPayload,\n  ) => {\n    const child = findInitialChildState(currentContext, stateConfigs, parent);\n    const transitionTargetState = child ? child : parent;\n    const rebuiltActiveStates =\n      rebuildActiveStates<TContext>(transitionTargetState, activeStates, stateConfigs);\n    if (rebuiltActiveStates !== activeStates) {\n      activeStates = rebuiltActiveStates;\n      matcherMemoization = {};\n      isDirty = true;\n      processCurrentStateEntryEvent<TPayload>(srcPayload);\n    } /* TODO: temporary state. Else case is important for it. */\n    if (isDirty) informListeners();\n  };\n\n  // EVENT PROCESSING\n\n  const processCurrentStateEntryEvent = <TPayload=any>(srcPayload: TPayload) => {\n    const cs = currentState();\n    if (cs.state.entry) processAnyEventHandler<TPayload>(cs.state.entry, cs, srcPayload);\n  };\n\n  const processAnyEventHandler = <TPayload=AnalyserNode>(\n    anyHandler: string|EventDef<TContext>|EventDef<TContext>[],\n    from: StateConfig<TContext>,\n    payload: TPayload,\n  ) => {\n    if (typeof anyHandler === 'string') {\n      transitionToTarget<TPayload>(anyHandler, from, payload);\n    } else if (anyHandler instanceof Array) {\n      processEvents<TPayload>(anyHandler, from, payload);\n    } else {\n      processEvents<TPayload>([anyHandler], from, payload);\n    }\n  };\n\n  const processEvents = <TPayload>(\n    defs: EventDef<TContext, TPayload>[],\n    from: StateConfig<TContext>,\n    payload: TPayload,\n  ) => {\n    const mutate = (def: EventDef<TContext>) => {\n      if (def.update) {\n        const update = updateContext(currentContext, def, payload);\n        if (update) {\n          currentContext = update;\n          isDirty = true;\n        }\n      } else if (def.replace) {\n        const replacement = def.replace(currentContext, payload);\n        if (replacement !== currentContext) {\n          currentContext = replacement;\n          isDirty = true;\n        }\n      }\n    };\n    const tap = (def: EventDef<TContext>) => {\n      if (def.tap) def.tap(currentContext, payload);\n    };\n    const dispatch = (def: EventDef<TContext>) => {\n      if (typeof def.next === 'string') send(def.next, payload);\n      else if (def.next) send(...def.next(currentContext, payload));\n      else if (isDirty) informListeners();\n    };\n    const transitionOrDispatch = (def: EventDef<TContext>) => {\n      if (def.target && !def.next) transitionToTarget(def.target, from, payload);\n      else if (!def.target && def.next) dispatch(def);\n      else if (isDirty) informListeners();\n    };\n    for (const def of defs) {\n      if (def.cond && def.cond(currentContext, payload)) {\n        mutate(def);\n        tap(def);\n        transitionOrDispatch(def);\n        break;\n      } else if (!def.cond) {\n        mutate(def);\n        tap(def);\n        transitionOrDispatch(def);\n      } else if (isDirty) {\n        informListeners();\n      }\n    }\n  };\n\n  const send = <TPayload=any>(\n    name: string,\n    payload: TPayload|Promise<TPayload>,\n  ) => {\n    const continueWithPayload = (\n      eventName: string,\n      eventPayload: TPayload|EventErrorType,\n    ) => {\n      const [anyHandler, config] = findEventHandlerAndStateConfig(eventName);\n      if (anyHandler && config) {\n        if (eventPayload && ('error' in eventPayload)) {\n          processAnyEventHandler<EventErrorType>(anyHandler, config, eventPayload);\n        } else {\n          processAnyEventHandler<TPayload>(anyHandler, config, eventPayload);\n        }\n      }\n    };\n\n    if (payload instanceof Promise) {\n      eventPayloadPromises.set(name, payload);\n      if (isDirty) {\n        // In case the event originated in a next, we should transitions before waiting for the promise to resolve\n        informListeners();\n      }\n      (async () => {\n        try {\n          const success = await payload;\n          if (eventPayloadPromises.get(name) === payload) {\n            eventPayloadPromises.delete(name);\n            continueWithPayload(name, success);\n          }\n        } catch (error) {\n          eventPayloadPromises.delete(name);\n          continueWithPayload(name, {error});\n        }\n      })();\n    } else {\n      continueWithPayload(name, payload);\n    }\n  };\n\n  processCurrentStateEntryEvent<{}>({});\n\n  // PATH MATCHING\n\n  const matches = (positivMatchValue: boolean, paths: string[]) => {\n    const memoKey = JSON.stringify([positivMatchValue ? 1 : 0, ...paths]);\n    const memoValue = matcherMemoization[memoKey];\n    if (memoValue) return memoValue.result;\n\n    const cs = currentState();\n    for (const toMatch of paths) {\n      if (toMatch.startsWith('/')) {\n        const toMatchComps = toMatch.split('/');\n        const toMatchCompsLen = toMatchComps.length - 1; // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n        if (toMatchCompsLen === activeStates.length) {\n          if (toMatch === cs.path.absolute) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        } else if (toMatchCompsLen < activeStates.length) {\n          let foundMismatch = false;\n          for (let i = 1; i < toMatchComps.length; i++) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n            if (toMatchComps[i] !== activeStates[i-1].path.name) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n              foundMismatch = true;\n              break;\n            }\n          }\n          if (!foundMismatch) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        }\n      } else {\n        const absToMatch = resolvePath(cs.path.absolute, toMatch);\n        if (absToMatch === cs.path.absolute) {\n          matcherMemoization[memoKey] = {result: positivMatchValue};\n          return positivMatchValue;\n        }\n      }\n    }\n\n    matcherMemoization[memoKey] = {result: !positivMatchValue};\n    return !positivMatchValue;\n  };\n\n  return {\n    context: () => currentContext as Readonly<TContext>,\n    path: () => currentState().path.absolute,\n    send,\n    matchesOne: (...paths: string[]) => matches(true, paths),\n    matchesNone: (...paths: string[]) => matches(false, paths),\n    onTransition,\n  };\n}\n","import {\n  EventDef,\n  StateDef,\n  MachineDef,\n  Service,\n  ParallelService,\n  OnParallelTransitionFn,\n} from './types';\n\n// Machine definition typing helper functions\n\nexport const Event = <TContext, TPayload=any, TNextPayload=any>(def: EventDef<TContext, TPayload, TNextPayload>) => def;\nexport const Next = <TContext, TPayload, TNextPayload>(fn: (ctx: TContext, inputPayload: TPayload) => [string, TNextPayload]) => fn;\nexport const State = <TContext>(def: StateDef<TContext>) => def;\nexport const Machine = <TContext>(def: MachineDef<TContext>) => def;\n\nexport const DeferredNextEvent = <TContext=any, TPayload=any, TNextPayload=void>(\n  nextEventName: string,\n  deferredFn: (ctx: TContext, payload: TPayload) => Promise<TNextPayload>,\n) => Event<TContext, TPayload>({\n  next: Next<TContext, TPayload, Promise<TNextPayload>>(\n    (ctx: TContext, payload: TPayload) => [\n      nextEventName,\n      deferredFn(ctx, payload),\n    ],\n  ),\n});\n\n// Parallel service constructor\n\nexport const parallelize = <TContext>(\n  ...services: Service<Partial<TContext>>[]\n) :ParallelService<TContext> => {\n  const context = () :Readonly<TContext> =>\n    Object.assign({}, ...services.map(s => s.context()));\n\n  const paths = () :string[] => services.map(s => s.path());\n\n  const send = <TPayload=any>(name: string, payload?: TPayload|Promise<TPayload>) =>\n    services.forEach(s => s.send<TPayload>(name, payload));\n\n  const makeMatchesFn = (\n    positivMatchValue: boolean,\n    fns: ((...paths: string[]) => boolean)[],\n  ) => (...paths: string[]) => {\n    for (let fn of fns) {\n      if (fn(...paths)) return positivMatchValue;\n    }\n    return !positivMatchValue;\n  };\n  const matchesOne = makeMatchesFn(true, services.map(s => s.matchesOne));\n  const matchesNone = makeMatchesFn(false, services.map(s => s.matchesNone));\n\n  const onTransition = (callback: OnParallelTransitionFn<TContext>) :(() => void) => {\n    const unsubscribers = services.map(s => s.onTransition(() => {\n      callback(context(), paths());\n    }));\n    return () => unsubscribers.forEach(u => u());\n  };\n\n  return {context, paths, send, matchesOne, matchesNone, onTransition};\n};\n"],"names":[],"mappings":"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"}