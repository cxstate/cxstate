{"version":3,"file":"cxstate.es5.js","sources":["../src/lib.ts","../src/index.ts","../src/hook.ts","../src/fns.ts"],"sourcesContent":["import {\n  EventDef,\n  StateDef,\n  StateConfig,\n} from './types';\n\nexport function rebuildActiveStates<ContextType>(\n  currentState: StateConfig<ContextType>,\n  previousActiveStates: StateConfig<ContextType>[],\n  statePaths: StateConfig<ContextType>[],\n) {\n  if (previousActiveStates[previousActiveStates.length-1] === currentState) {\n    return previousActiveStates;\n  }\n  const comps = currentState.path.absolute.split('/').filter(c => c.length);\n  const acc: StateConfig<ContextType>[] = [];\n  for (let i = 1; i <= comps.length; i++) {\n    const path = `/${comps.slice(0, i).join('/')}`;\n    const parentResult = previousActiveStates.find(sp => sp.path.absolute === path);\n    const result = parentResult || statePaths.find(sp => sp.path.absolute === path);\n    if (result) acc.push(result);\n    else throw new Error(`No state found for path \"${path}\"`);\n  }\n  return acc;\n}\n\nexport function findInitialChildState<ContextType>(\n  ctx: ContextType,\n  statePaths: StateConfig<ContextType>[],\n  parent: StateConfig<ContextType>,\n) :StateConfig<ContextType>|undefined {\n  if (hasChildStates(parent.state)) {\n    if (parent.state.initial) {\n      let initial = initialStateName<ContextType>(parent.state.initial, ctx);\n      const basePath = parent.path.absolute.endsWith('/')\n        ? parent.path.absolute\n        : `${parent.path.absolute}/`;\n      const absolutePath = resolvePath(basePath, initial);\n      const child = statePaths.find(sp => sp.path.absolute === absolutePath);\n      if (child) {\n        if (hasChildStates(child.state)) {\n          return findInitialChildState(ctx, statePaths, child);\n        } else {\n          return child;\n        }\n      } else {\n        throw new Error(`State \"${parent.path.absolute}\" initial state \"${initial}\" doesn't match any of the definitions`);\n      }\n    } else {\n      throw new Error(`State \"${parent.path.absolute}\" has child-states, but doesn't define initial`);\n    }\n  }\n}\n\nfunction hasChildStates<ContextType>(state: StateDef<ContextType>) :boolean {\n  return !!(state.states && Object.values(state.states).length);\n}\n\nexport function updateContext<ContextType, EventType>(\n  ctx: ContextType,\n  def: EventDef<ContextType>,\n  event?: EventType,\n) {\n  const update = {...ctx};\n  let didUpdate = false;\n  for (const propName in def.update) {\n    const anyFn = def.update[propName];\n    if (typeof anyFn === 'function') {\n      const fn = anyFn as (ctx: ContextType, ev?: EventType) => any;\n      update[propName] = fn(update, event);\n      didUpdate = true;\n    }\n  }\n  if (didUpdate) return update;\n}\n\nexport function initialStateName<ContextType>(\n  initial: string|((ctx: ContextType) => string),\n  ctx: ContextType,\n) {\n  return (typeof initial === 'string') ? initial : initial(ctx);\n}\n\nexport function resolvePath(base: string, relativeComp: string) {\n  if (!base.startsWith('/')) throw new Error('Base component of path must start with /');\n  const host = 'http://con5.app';\n  const url = (new URL(relativeComp, `${host}${base}`)).href;\n  return url.slice(host.length);\n}\n","import {\n  EventDef,\n  EventErrorType,\n  StateDef,\n  MachineDef,\n  Service,\n  StateConfig,\n  OnTransitionFn,\n} from './types';\n\nimport {\n  rebuildActiveStates,\n  findInitialChildState,\n  updateContext,\n  initialStateName,\n  resolvePath,\n} from './lib';\n\n/**\n * Internprets a machine-definition. Returns a ready to use machine-service.\n */\nexport function interpret<ContextType>(machineDef: MachineDef<ContextType>)\n:Service<ContextType> {\n  const stateConfigs: StateConfig<ContextType>[] = [];\n\n  const buildStateConfigs = (\n    basePath: string,\n    name: string,\n    state: StateDef<ContextType>,\n  ) => {\n    const absolute = resolvePath(basePath, name);\n    stateConfigs.push({state, path: {name, absolute}});\n\n    if (state.states && Object.values(state.states).length) {\n      // Check minimum state validity\n      if (!state.initial) throw new Error(`State \"${absolute}\" has child-states, but doesn't define initial`);\n      // Check minimum validity of events\n      if (state.on) Object.entries(state.on).forEach(([eventName, eventDef]) => {\n        const checkEvent = (ed: string|EventDef<ContextType>) => {\n          if (typeof ed !== 'string') {\n            if (ed.replace && ed.update) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <replace> and <update> are mutually exclusive`);\n            if (ed.target && ed.next) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <target> and <next> are mutually exclusive`);\n          }\n        };\n        if (eventDef instanceof Array) eventDef.forEach(checkEvent);\n        else checkEvent(eventDef);\n      });\n      const nextBasePath = absolute.endsWith('/') ? absolute : `${absolute}/`;\n      for (const [stateName, stateDef] of Object.entries(state.states)) {\n        buildStateConfigs(nextBasePath, stateName, stateDef);\n      }\n    }\n  };\n\n  for (const [stateName, stateDef] of Object.entries(machineDef.states)) {\n    buildStateConfigs('/', stateName, stateDef);\n  }\n\n  let initial = initialStateName<ContextType>(machineDef.initial, machineDef.context);\n  const initialAbsPath = initial.startsWith('/') ? initial : `/${initial}`;\n  let initialState = stateConfigs.find(sp => sp.path.absolute === initialAbsPath);\n  if (initialState) {\n    const initialChild = findInitialChildState(machineDef.context, stateConfigs, initialState);\n    if (initialChild) {\n      initialState = initialChild;\n    }\n    return makeService(stateConfigs, machineDef.context, initialState);\n  } else {\n    throw new Error(`Initial state \"${initial}\" doesn't match any of the definitions`);\n  }\n}\n\nfunction makeService<ContextType>(\n  stateConfigs: StateConfig<ContextType>[],\n  initialContext: ContextType,\n  initialState: StateConfig<ContextType>,\n) :Service<ContextType> {\n  let activeStates: StateConfig<ContextType>[] =\n    rebuildActiveStates<ContextType>(initialState, [], stateConfigs);\n  let currentContext: ContextType = initialContext;\n  const listeners: OnTransitionFn<ContextType>[] = [];\n  let matcherMemoization: {[key:string]: {result: boolean}} = {};\n  const eventPayloadPromises = new Map<string, Promise<any>>();\n  let isDirty: boolean = true;\n\n  const currentState = () => activeStates[activeStates.length - 1];\n\n  const findEventHandlerAndStateConfig = (eventName: string)\n  :[\n    string|EventDef<ContextType>|EventDef<ContextType>[]|null,\n    StateConfig<ContextType>|null,\n  ] => {\n    for(let i = activeStates.length; i--;) {\n      const config = activeStates[i];\n      if (config.state.on) {\n        const handler = config.state.on[eventName];\n        if (handler) return [handler, config];\n      }\n    }\n    return [null, null];\n  };\n\n  const informListeners = () => {\n    for (const callback of listeners) {\n      callback(currentContext, currentState().path.absolute);\n    }\n    isDirty = false;\n  };\n\n  // TRANSITION HANDLING\n\n  const onTransition = (callback: OnTransitionFn<ContextType>) => {\n    listeners.push(callback);\n    return () => {\n      const idx = listeners.indexOf(callback);\n      if (idx > -1) listeners.splice(idx, 1);\n    };\n  };\n\n  // from: state path in which the event handler was found\n  const transitionToTarget = <EventType>(\n    target: string,\n    from: StateConfig<ContextType>,\n    srcEvent: EventType,\n  ) => {\n    if (target) {\n      const fsp = from.path;\n      const targetPath = resolvePath(`${fsp.absolute}/`, target);\n      const targetConfig = stateConfigs.find(sc => sc.path.absolute === targetPath);\n      if (targetConfig) {\n        transitionToState<EventType>(targetConfig, srcEvent);\n      } else {\n        throw new Error(`No state defined for path \"${targetPath}\"`);\n      }\n    } else if (isDirty) {\n      informListeners();\n    }\n  };\n\n  // ACTIVE STATE HANDLING\n\n  const transitionToState = <EventType>(\n    parent: StateConfig<ContextType>,\n    srcEvent: EventType,\n  ) => {\n    const child = findInitialChildState(currentContext, stateConfigs, parent);\n    const transitionTargetState = child ? child : parent;\n    const rebuiltActiveStates =\n      rebuildActiveStates<ContextType>(transitionTargetState, activeStates, stateConfigs);\n    if (rebuiltActiveStates !== activeStates) {\n      activeStates = rebuiltActiveStates;\n      matcherMemoization = {};\n      isDirty = true;\n      processCurrentStateEntryEvent<EventType>(srcEvent);\n    } /* TODO: temporary state. Else case is important for it. */\n    if (isDirty) informListeners();\n  };\n\n  // EVENT PROCESSING\n\n  const processCurrentStateEntryEvent = <EventType=any>(srcEvent: EventType) => {\n    const cs = currentState();\n    if (cs.state.entry) processAnyEventHandler<EventType>(cs.state.entry, cs, srcEvent);\n  };\n\n  const processAnyEventHandler = <EventType=AnalyserNode>(\n    anyHandler: string|EventDef<ContextType>|EventDef<ContextType>[],\n    from: StateConfig<ContextType>,\n    event: EventType,\n  ) => {\n    if (typeof anyHandler === 'string') {\n      transitionToTarget<EventType>(anyHandler, from, event);\n    } else if (anyHandler instanceof Array) {\n      processEvents<EventType>(anyHandler, from, event);\n    } else {\n      processEvents<EventType>([anyHandler], from, event);\n    }\n  };\n\n  const processEvents = <EventType>(\n    defs: EventDef<ContextType, EventType>[],\n    from: StateConfig<ContextType>,\n    event: EventType,\n  ) => {\n    const mutate = (def: EventDef<ContextType>) => {\n      if (def.update) {\n        const update = updateContext(currentContext, def, event);\n        if (update) {\n          currentContext = update;\n          isDirty = true;\n        }\n      } else if (def.replace) {\n        const replacement = def.replace(currentContext, event);\n        if (replacement !== currentContext) {\n          currentContext = replacement;\n          isDirty = true;\n        }\n      }\n    };\n    const dispatch = (def: EventDef<ContextType>) => {\n      if (typeof def.next === 'string') send(def.next, event);\n      else if (def.next) send(...def.next(currentContext, event));\n      else if (isDirty) informListeners();\n    };\n    const transitionOrDispatch = (def: EventDef<ContextType>) => {\n      if (def.target && !def.next) transitionToTarget(def.target, from, event);\n      else if (!def.target && def.next) dispatch(def);\n      else if (isDirty) informListeners();\n    };\n    for (const def of defs) {\n      if (def.cond && def.cond(currentContext, event)) {\n        mutate(def);\n        transitionOrDispatch(def);\n        break;\n      } else if (!def.cond) {\n        mutate(def);\n        transitionOrDispatch(def);\n      }\n    }\n  };\n\n  const send = <EventType=any>(\n    name: string,\n    event: EventType|Promise<EventType>,\n  ) => {\n    const continueWithPayload = (\n      eventName: string,\n      eventPayload: EventType|EventErrorType,\n    ) => {\n      const [anyHandler, config] = findEventHandlerAndStateConfig(eventName);\n      if (anyHandler && config) {\n        if (eventPayload && ('error' in eventPayload)) {\n          processAnyEventHandler<EventErrorType>(anyHandler, config, eventPayload);\n        } else {\n          processAnyEventHandler<EventType>(anyHandler, config, eventPayload);\n        }\n      }\n    };\n\n    if (event instanceof Promise) {\n      eventPayloadPromises.set(name, event);\n      (async () => {\n        try {\n          const success = await event;\n          if (eventPayloadPromises.get(name) === event) {\n            eventPayloadPromises.delete(name);\n            continueWithPayload(name, success);\n          }\n        } catch (error) {\n          eventPayloadPromises.delete(name);\n          continueWithPayload(name, {error});\n        }\n      })();\n    } else {\n      continueWithPayload(name, event);\n    }\n  };\n\n  processCurrentStateEntryEvent<{}>({});\n\n  // PATH MATCHING\n\n  const matches = (positivMatchValue: boolean, paths: string[]) => {\n    const memoKey = JSON.stringify([positivMatchValue ? 1 : 0, ...paths]);\n    const memoValue = matcherMemoization[memoKey];\n    if (memoValue) return memoValue.result;\n\n    const cs = currentState();\n    for (const toMatch of paths) {\n      if (toMatch.startsWith('/')) {\n        const toMatchComps = toMatch.split('/');\n        const toMatchCompsLen = toMatchComps.length - 1; // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n        if (toMatchCompsLen === activeStates.length) {\n          if (toMatch === cs.path.absolute) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        } else if (toMatchCompsLen < activeStates.length) {\n          let foundMismatch = false;\n          for (let i = 1; i < toMatchComps.length; i++) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n            if (toMatchComps[i] !== activeStates[i-1].path.name) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n              foundMismatch = true;\n              break;\n            }\n          }\n          if (!foundMismatch) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        }\n      } else {\n        const absToMatch = resolvePath(cs.path.absolute, toMatch);\n        if (absToMatch === cs.path.absolute) {\n          matcherMemoization[memoKey] = {result: positivMatchValue};\n          return positivMatchValue;\n        }\n      }\n    }\n\n    matcherMemoization[memoKey] = {result: !positivMatchValue};\n    return !positivMatchValue;\n  };\n\n  return {\n    context: () => currentContext,\n    path: () => currentState().path.absolute,\n    send,\n    matchesOne: (...paths: string[]) => matches(true, paths),\n    matchesNone: (...paths: string[]) => matches(false, paths),\n    onTransition,\n  };\n}\n","import { useEffect, useState } from 'react';\nimport { interpret } from '.';\nimport { MachineDef, Service, SendFn, CurrentMachineState } from './types';\n\ninterface HookState<ContextType> {\n  path: string\n  context: ContextType;\n}\n\nexport function useMachine<ContextType>(machineDef: MachineDef<ContextType>) :[CurrentMachineState<ContextType>, SendFn] {\n  const [service] = useState<Service<ContextType>>(\n    () => interpret<ContextType>(machineDef),\n  );\n  const [state, setState] = useState<HookState<ContextType>>({\n    path: service.path(),\n    context: service.context(),\n  });\n  useEffect(\n    () => service.onTransition((context: ContextType, path: string) => {\n      setState({context, path});\n    }),\n    [service, setState],\n  );\n  return [\n    {\n      ...state,\n      matchesOne: service.matchesOne,\n      matchesNone: service.matchesNone,\n    },\n    service.send,\n  ];\n}\n","import {\n  EventDef,\n  StateDef,\n  MachineDef,\n} from './types';\n\nexport const Event = <ContextType, EventType=any, NextEventType=any>(def: EventDef<ContextType, EventType, NextEventType>) => def;\nexport const Next = <ContextType, EventType, NextEventType>(fn: (ctx: ContextType, eventA: EventType) => [string, NextEventType]) => fn;\nexport const State = <ContextType>(def: StateDef<ContextType>) => def;\nexport const Machine = <ContextType>(def: MachineDef<ContextType>) => def;\n"],"names":[],"mappings":"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"}