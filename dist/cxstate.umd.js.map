{"version":3,"file":"cxstate.umd.js","sources":["../src/lib.ts","../src/index.ts","../src/fns.ts"],"sourcesContent":["import {\n  EventDef,\n  StateDef,\n  StateConfig,\n} from './types';\n\nexport function rebuildActiveStates<ContextType>(\n  currentState: StateConfig<ContextType>,\n  previousActiveStates: StateConfig<ContextType>[],\n  statePaths: StateConfig<ContextType>[],\n) {\n  if (previousActiveStates[previousActiveStates.length-1] === currentState) {\n    return previousActiveStates;\n  }\n  const comps = currentState.path.absolute.split('/').filter(c => c.length);\n  const acc: StateConfig<ContextType>[] = [];\n  for (let i = 1; i <= comps.length; i++) {\n    const path = `/${comps.slice(0, i).join('/')}`;\n    const parentResult = previousActiveStates.find(sp => sp.path.absolute === path);\n    const result = parentResult || statePaths.find(sp => sp.path.absolute === path);\n    if (result) acc.push(result);\n    else throw new Error(`No state found for path \"${path}\"`);\n  }\n  return acc;\n}\n\nexport function findInitialChildState<ContextType>(\n  ctx: ContextType,\n  statePaths: StateConfig<ContextType>[],\n  parent: StateConfig<ContextType>,\n) :StateConfig<ContextType>|undefined {\n  if (hasChildStates(parent.state)) {\n    if (parent.state.initial) {\n      let initial = initialStateName<ContextType>(parent.state.initial, ctx);\n      const basePath = parent.path.absolute.endsWith('/')\n        ? parent.path.absolute\n        : `${parent.path.absolute}/`;\n      const absolutePath = resolvePath(basePath, initial);\n      const child = statePaths.find(sp => sp.path.absolute === absolutePath);\n      if (child) {\n        if (hasChildStates(child.state)) {\n          return findInitialChildState(ctx, statePaths, child);\n        } else {\n          return child;\n        }\n      } else {\n        throw new Error(`State \"${parent.path.absolute}\" initial state \"${initial}\" doesn't match any of the definitions`);\n      }\n    } else {\n      throw new Error(`State \"${parent.path.absolute}\" has child-states, but doesn't define initial`);\n    }\n  }\n}\n\nfunction hasChildStates<ContextType>(state: StateDef<ContextType>) :boolean {\n  return !!(state.states && Object.values(state.states).length);\n}\n\nexport function updateContext<ContextType, EventType>(\n  ctx: ContextType,\n  def: EventDef<ContextType>,\n  event?: EventType,\n) {\n  console.log('UPDATING CONTEXT');\n  const update = {...ctx};\n  let didUpdate = false;\n  for (const propName in def.update) {\n    const anyFn = def.update[propName];\n    if (typeof anyFn === 'function') {\n      const fn = anyFn as (ctx: ContextType, ev?: EventType) => any;\n      const changedValue = fn(update, event);\n      if (changedValue !== update[propName]) {\n        update[propName] = changedValue;\n        didUpdate = true;\n      }\n    }\n  }\n  if (didUpdate) return update;\n}\n\nexport function initialStateName<ContextType>(\n  initial: string|((ctx: ContextType) => string),\n  ctx: ContextType,\n) {\n  return (typeof initial === 'string') ? initial : initial(ctx);\n}\n\nexport function resolvePath(base: string, relativeComp: string) {\n  if (!base.startsWith('/')) throw new Error('Base component of path must start with /');\n  const host = 'http://con5.app';\n  const url = (new URL(relativeComp, `${host}${base}`)).href;\n  return url.slice(host.length);\n}\n","import {\n  EventDef,\n  EventErrorType,\n  StateDef,\n  MachineDef,\n  Service,\n  StateConfig,\n  OnTransitionFn,\n} from './types';\n\nimport {\n  rebuildActiveStates,\n  findInitialChildState,\n  updateContext,\n  initialStateName,\n  resolvePath,\n} from './lib';\n\n/**\n * Internprets a machine-definition. Returns a ready to use machine-service.\n */\nexport function interpret<ContextType>(machineDef: MachineDef<ContextType>)\n:Service<ContextType> {\n  const stateConfigs: StateConfig<ContextType>[] = [];\n\n  const buildStateConfigs = (\n    basePath: string,\n    name: string,\n    state: StateDef<ContextType>,\n  ) => {\n    const absolute = resolvePath(basePath, name);\n    stateConfigs.push({state, path: {name, absolute}});\n\n    if (state.states && Object.values(state.states).length) {\n      // Check minimum state validity\n      if (!state.initial) throw new Error(`State \"${absolute}\" has child-states, but doesn't define initial`);\n      // Check minimum validity of events\n      if (state.on) Object.entries(state.on).forEach(([eventName, eventDef]) => {\n        const checkEvent = (ed: string|EventDef<ContextType>) => {\n          if (typeof ed !== 'string') {\n            if (ed.replace && ed.update) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <replace> and <update> are mutually exclusive`);\n            if (ed.target && ed.next) throw new Error(`State\"${absolute}\" / Event \"${eventName}\": <target> and <next> are mutually exclusive`);\n          }\n        };\n        if (eventDef instanceof Array) eventDef.forEach(checkEvent);\n        else checkEvent(eventDef);\n      });\n      const nextBasePath = absolute.endsWith('/') ? absolute : `${absolute}/`;\n      for (const [stateName, stateDef] of Object.entries(state.states)) {\n        buildStateConfigs(nextBasePath, stateName, stateDef);\n      }\n    }\n  };\n\n  for (const [stateName, stateDef] of Object.entries(machineDef.states)) {\n    buildStateConfigs('/', stateName, stateDef);\n  }\n\n  let initial = initialStateName<ContextType>(machineDef.initial, machineDef.context);\n  const initialAbsPath = initial.startsWith('/') ? initial : `/${initial}`;\n  let initialState = stateConfigs.find(sp => sp.path.absolute === initialAbsPath);\n  if (initialState) {\n    const initialChild = findInitialChildState(machineDef.context, stateConfigs, initialState);\n    if (initialChild) {\n      initialState = initialChild;\n    }\n    return makeService(stateConfigs, machineDef.context, initialState);\n  } else {\n    throw new Error(`Initial state \"${initial}\" doesn't match any of the definitions`);\n  }\n}\n\nfunction makeService<ContextType>(\n  stateConfigs: StateConfig<ContextType>[],\n  initialContext: ContextType,\n  initialState: StateConfig<ContextType>,\n) :Service<ContextType> {\n  let activeStates: StateConfig<ContextType>[] =\n    rebuildActiveStates<ContextType>(initialState, [], stateConfigs);\n  let currentContext: ContextType = initialContext;\n  const listeners: OnTransitionFn<ContextType>[] = [];\n  let matcherMemoization: {[key:string]: {result: boolean}} = {};\n  const eventPayloadPromises = new Map<string, Promise<any>>();\n  let isDirty: boolean = true;\n\n  const currentState = () => activeStates[activeStates.length - 1];\n\n  const findEventHandlerAndStateConfig = (eventName: string)\n  :[\n    string|EventDef<ContextType>|EventDef<ContextType>[]|null,\n    StateConfig<ContextType>|null,\n  ] => {\n    for(let i = activeStates.length; i--;) {\n      const config = activeStates[i];\n      if (config.state.on) {\n        const handler = config.state.on[eventName];\n        if (handler) return [handler, config];\n      }\n    }\n    return [null, null];\n  };\n\n  const informListeners = () => {\n    for (const callback of listeners) {\n      callback(currentContext, currentState().path.absolute);\n    }\n    isDirty = false;\n  };\n\n  // TRANSITION HANDLING\n\n  const onTransition = (callback: OnTransitionFn<ContextType>) => {\n    listeners.push(callback);\n    return () => {\n      const idx = listeners.indexOf(callback);\n      if (idx > -1) listeners.splice(idx, 1);\n    };\n  };\n\n  // from: state path in which the event handler was found\n  const transitionToTarget = <EventType>(\n    target: string,\n    from: StateConfig<ContextType>,\n    srcEvent: EventType,\n  ) => {\n    if (target) {\n      const fsp = from.path;\n      const targetPath = resolvePath(`${fsp.absolute}/`, target);\n      const targetConfig = stateConfigs.find(sc => sc.path.absolute === targetPath);\n      if (targetConfig) {\n        transitionToState<EventType>(targetConfig, srcEvent);\n      } else {\n        throw new Error(`No state defined for path \"${targetPath}\"`);\n      }\n    } else if (isDirty) {\n      informListeners();\n    }\n  };\n\n  // ACTIVE STATE HANDLING\n\n  const transitionToState = <EventType>(\n    parent: StateConfig<ContextType>,\n    srcEvent: EventType,\n  ) => {\n    const child = findInitialChildState(currentContext, stateConfigs, parent);\n    const transitionTargetState = child ? child : parent;\n    const rebuiltActiveStates =\n      rebuildActiveStates<ContextType>(transitionTargetState, activeStates, stateConfigs);\n    if (rebuiltActiveStates !== activeStates) {\n      activeStates = rebuiltActiveStates;\n      matcherMemoization = {};\n      isDirty = true;\n      processCurrentStateEntryEvent<EventType>(srcEvent);\n    } /* TODO: temporary state. Else case is important for it. */\n    if (isDirty) informListeners();\n  };\n\n  // EVENT PROCESSING\n\n  const processCurrentStateEntryEvent = <EventType=any>(srcEvent: EventType) => {\n    const cs = currentState();\n    if (cs.state.entry) processAnyEventHandler<EventType>(cs.state.entry, cs, srcEvent);\n  };\n\n  const processAnyEventHandler = <EventType=AnalyserNode>(\n    anyHandler: string|EventDef<ContextType>|EventDef<ContextType>[],\n    from: StateConfig<ContextType>,\n    event: EventType,\n  ) => {\n    if (typeof anyHandler === 'string') {\n      transitionToTarget<EventType>(anyHandler, from, event);\n    } else if (anyHandler instanceof Array) {\n      processEvents<EventType>(anyHandler, from, event);\n    } else {\n      processEvents<EventType>([anyHandler], from, event);\n    }\n  };\n\n  const processEvents = <EventType>(\n    defs: EventDef<ContextType, EventType>[],\n    from: StateConfig<ContextType>,\n    event: EventType,\n  ) => {\n    const mutate = (def: EventDef<ContextType>) => {\n      if (def.update) {\n        const update = updateContext(currentContext, def, event);\n        if (update) {\n          currentContext = update;\n          isDirty = true;\n        }\n      } else if (def.replace) {\n        const replacement = def.replace(currentContext, event);\n        if (replacement !== currentContext) {\n          currentContext = replacement;\n          isDirty = true;\n        }\n      }\n    };\n    const dispatch = (def: EventDef<ContextType>) => {\n      if (typeof def.next === 'string') send(def.next, event);\n      else if (def.next) send(...def.next(currentContext, event));\n      else if (isDirty) informListeners();\n    };\n    const transitionOrDispatch = (def: EventDef<ContextType>) => {\n      if (def.target && !def.next) transitionToTarget(def.target, from, event);\n      else if (!def.target && def.next) dispatch(def);\n      else if (isDirty) informListeners();\n    };\n    for (const def of defs) {\n      if (def.cond && def.cond(currentContext, event)) {\n        mutate(def);\n        transitionOrDispatch(def);\n        break;\n      } else if (!def.cond) {\n        mutate(def);\n        transitionOrDispatch(def);\n      }\n    }\n  };\n\n  const send = <EventType=any>(\n    name: string,\n    event: EventType|Promise<EventType>,\n  ) => {\n    const continueWithPayload = (\n      eventName: string,\n      eventPayload: EventType|EventErrorType,\n    ) => {\n      const [anyHandler, config] = findEventHandlerAndStateConfig(eventName);\n      if (anyHandler && config) {\n        if (eventPayload && ('error' in eventPayload)) {\n          processAnyEventHandler<EventErrorType>(anyHandler, config, eventPayload);\n        } else {\n          processAnyEventHandler<EventType>(anyHandler, config, eventPayload);\n        }\n      }\n    };\n\n    if (event instanceof Promise) {\n      eventPayloadPromises.set(name, event);\n      (async () => {\n        try {\n          const success = await event;\n          if (eventPayloadPromises.get(name) === event) {\n            eventPayloadPromises.delete(name);\n            continueWithPayload(name, success);\n          }\n        } catch (error) {\n          eventPayloadPromises.delete(name);\n          continueWithPayload(name, {error});\n        }\n      })();\n    } else {\n      continueWithPayload(name, event);\n    }\n  };\n\n  processCurrentStateEntryEvent<{}>({});\n\n  // PATH MATCHING\n\n  const matches = (positivMatchValue: boolean, paths: string[]) => {\n    const memoKey = JSON.stringify([positivMatchValue ? 1 : 0, ...paths]);\n    const memoValue = matcherMemoization[memoKey];\n    if (memoValue) return memoValue.result;\n\n    const cs = currentState();\n    for (const toMatch of paths) {\n      if (toMatch.startsWith('/')) {\n        const toMatchComps = toMatch.split('/');\n        const toMatchCompsLen = toMatchComps.length - 1; // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n        if (toMatchCompsLen === activeStates.length) {\n          if (toMatch === cs.path.absolute) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        } else if (toMatchCompsLen < activeStates.length) {\n          let foundMismatch = false;\n          for (let i = 1; i < toMatchComps.length; i++) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n            if (toMatchComps[i] !== activeStates[i-1].path.name) { // LEADING \"/\" CAUSES 1 COMP OVERFLOW\n              foundMismatch = true;\n              break;\n            }\n          }\n          if (!foundMismatch) {\n            matcherMemoization[memoKey] = {result: positivMatchValue};\n            return positivMatchValue;\n          }\n        }\n      } else {\n        const absToMatch = resolvePath(cs.path.absolute, toMatch);\n        if (absToMatch === cs.path.absolute) {\n          matcherMemoization[memoKey] = {result: positivMatchValue};\n          return positivMatchValue;\n        }\n      }\n    }\n\n    matcherMemoization[memoKey] = {result: !positivMatchValue};\n    return !positivMatchValue;\n  };\n\n  return {\n    context: () => currentContext,\n    path: () => currentState().path.absolute,\n    send,\n    matchesOne: (...paths: string[]) => matches(true, paths),\n    matchesNone: (...paths: string[]) => matches(false, paths),\n    onTransition,\n  };\n}\n","import {\n  EventDef,\n  StateDef,\n  MachineDef,\n} from './types';\n\nexport const Event = <ContextType, EventType=any, NextEventType=any>(def: EventDef<ContextType, EventType, NextEventType>) => def;\nexport const Next = <ContextType, EventType, NextEventType>(fn: (ctx: ContextType, eventA: EventType) => [string, NextEventType]) => fn;\nexport const State = <ContextType>(def: StateDef<ContextType>) => def;\nexport const Machine = <ContextType>(def: MachineDef<ContextType>) => def;\n"],"names":[],"mappings":"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"}